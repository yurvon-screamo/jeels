# Дизайн-спецификация системы Jeers

## Введение

Система Jeers представляет собой минималистичный аналог Anki для интервального повторения материала, специально оптимизированный для изучения японского языка. Она фокусируется на создании и управлении карточками, а также на процессе изучения и повторения. Архитектура построена в стиле Clean Architecture с использованием Domain-Driven Design (DDD).

Система использует алгоритм FSRS для расчета оптимальных интервалов повторения, векторные embeddings для поиска похожих карточек, и интеграцию с LLM для автоматической генерации переводов и примеров использования слов.

## User Stories

Пользовательские истории сгруппированы по функциональным требованиям (FR) и описывают основные потребности пользователя.

### FR1: Создание и управление карточками

Это требование охватывает добавление, редактирование и удаление контента для изучения в едином пространстве.

- Как пользователь, я хочу создавать новые карточки с вопросом и ответом, чтобы добавлять материал для запоминания.
- Как пользователь, я хочу создавать карточки массово, указывая только вопросы, чтобы система автоматически генерировала переводы.
- Как пользователь, я хочу редактировать существующие карточки, чтобы исправлять ошибки или обновлять информацию.
- Как пользователь, я хочу удалять карточки, чтобы избавляться от ненужного контента.
- Как пользователь, я хочу импортировать карточки из Anki, чтобы перенести существующую коллекцию.
- Как пользователь, я хочу импортировать карточки из Migii, чтобы использовать готовые уроки.
- Как пользователь, я хочу видеть похожие карточки при изучении, чтобы лучше понимать контекст и избегать дубликатов.

### FR2: Изучение и повторение карточек

Это требование фокусируется на взаимодействии с карточками и автоматизации повторений.

- Как пользователь, я хочу просматривать карточки в режиме изучения, чтобы видеть вопрос, а затем ответ.
- Как пользователь, я хочу видеть примеры использования слова, чтобы лучше понимать контекст.
- Как пользователь, я хочу видеть фуригану для японского текста, чтобы правильно читать слова.
- Как пользователь, я хочу переворачивать карточки (изучать в обратном направлении), чтобы лучше запоминать материал.
- Как пользователь, я хочу оценивать свой ответ (например, "легко", "хорошо", "трудно", "забыл"), чтобы приложение учитывало мою уверенность в запоминании.
- Как пользователь, я хочу, чтобы приложение автоматически планировало повторения на основе моих оценок, чтобы я повторял материал в оптимальное время и не забывал его.
- Как пользователь, я хочу видеть статистику своих уроков, чтобы отслеживать прогресс.

### FR3: Управление профилем и настройками

- Как пользователь, я хочу указывать свой родной язык, чтобы система генерировала переводы на правильном языке.
- Как пользователь, я хочу указывать свой уровень японского языка, чтобы система адаптировала примеры под мой уровень.
- Как пользователь, я хочу устанавливать лимит новых карточек в день, чтобы контролировать нагрузку.

## Сценарии использования (Use Cases)

Каждый сценарий описывает актера, предусловия, основной поток, альтернативные потоки и постусловия. Они полностью покрывают пользовательские истории.

### FR1: Создание и управление карточками

#### Use Case 1: Создание новой карточки

- **Актер**: Пользователь.
- **Предусловия**: Пользователь находится в разделе управления карточками.
- **Основной поток**:
  1. Пользователь выбирает опцию "Создать карточку".
  2. Пользователь вводит вопрос (японское слово).
  3. Пользователь может указать ответ (перевод) или оставить его пустым для автоматической генерации.
  4. Система генерирует embedding для вопроса для поиска похожих карточек.
  5. Если ответ не указан, система генерирует перевод через LLM с учетом родного языка пользователя.
  6. Система генерирует примеры использования слова через LLM с учетом уровня японского языка пользователя.
  7. Пользователь подтверждает создание.
- **Альтернативные потоки**:
  - Если поля пустые, система показывает ошибку и возвращает к шагу 2.
  - Если карточка с похожим вопросом уже существует (проверка через embedding similarity), система показывает ошибку дубликата и возвращает к шагу 2.
  - Если генерация перевода или примеров не удалась, система показывает ошибку и возвращает к шагу 2.
- **Постусловия**: Новая карточка добавлена в пространство, отображается подтверждение.

#### Use Case 2: Массовое создание карточек

- **Актер**: Пользователь.
- **Предусловия**: Пользователь находится в разделе управления карточками.
- **Основной поток**:
  1. Пользователь выбирает опцию "Создать карточки массово".
  2. Пользователь вводит список вопросов (японских слов).
  3. Для каждого вопроса система автоматически генерирует перевод и примеры использования.
  4. Система создает все карточки.
- **Альтернативные потоки**:
  - Если какой-то вопрос дублирует существующую карточку, система пропускает его и продолжает с остальными.
  - Если генерация для какой-то карточки не удалась, система пропускает ее и продолжает с остальными.
- **Постусловия**: Созданные карточки добавлены в пространство, отображается количество успешно созданных карточек.

#### Use Case 3: Редактирование существующей карточки

- **Актер**: Пользователь.
- **Предусловия**: Карточка существует, пользователь в списке карточек.
- **Основной поток**:
  1. Пользователь выбирает карточку для редактирования.
  2. Пользователь изменяет вопрос, ответ или примеры использования.
  3. Если вопрос изменен, система обновляет embedding.
  4. Пользователь подтверждает изменения.
- **Альтернативные потоки**:
  - Если изменений нет, система предлагает отменить.
  - Если новый вопрос дублирует вопрос другой существующей карточки (проверка через embedding similarity), система показывает ошибку дубликата и возвращает к шагу 2.
- **Постусловия**: Карточка обновлена, отображается актуальная версия.

#### Use Case 4: Удаление карточки

- **Актер**: Пользователь.
- **Предусловия**: Карточка существует, пользователь в списке карточек.
- **Основной поток**:
  1. Пользователь выбирает карточку для удаления.
  2. Пользователь подтверждает действие (с предупреждением).
- **Альтернативные потоки**: Если пользователь отменяет, возвращение к списку.
- **Постусловия**: Карточка удалена, список обновлен.

#### Use Case 5: Импорт карточек из Anki

- **Актер**: Пользователь.
- **Предусловия**: У пользователя есть файл колоды Anki.
- **Основной поток**:
  1. Пользователь выбирает опцию "Импорт из Anki".
  2. Пользователь указывает путь к файлу колоды Anki.
  3. Пользователь указывает теги полей для слова и перевода.
  4. Система парсит файл и извлекает карточки.
  5. Для каждой карточки система создает embedding и генерирует примеры использования.
  6. Система создает все карточки.
- **Альтернативные потоки**:
  - Если файл невалиден, система показывает ошибку.
  - Если перевод не указан, система генерирует его автоматически.
  - Если какая-то карточка дублирует существующую, система пропускает ее.
- **Постусловия**: Импортированные карточки добавлены в пространство.

#### Use Case 6: Импорт карточек из Migii

- **Актер**: Пользователь.
- **Предусловия**: Пользователь имеет доступ к урокам Migii.
- **Основной поток**:
  1. Пользователь выбирает опцию "Импорт из Migii".
  2. Пользователь указывает номера уроков для импорта.
  3. Система извлекает слова из указанных уроков.
  4. Для каждого слова система создает карточку с автоматической генерацией перевода и примеров.
- **Альтернативные потоки**:
  - Если урок не найден, система пропускает его.
  - Если пользователь указал опцию "только вопросы", система не генерирует переводы.
- **Постусловия**: Импортированные карточки добавлены в пространство.

### FR2: Изучение и повторение карточек

#### Use Case 7: Просмотр карточки в режиме изучения

- **Актер**: Пользователь.
- **Предусловия**: Есть карточки, пользователь начинает сессию изучения.
- **Основной поток**:
  1. Система показывает вопрос (или ответ, если карточка перевернута).
  2. Пользователь может запросить показ фуриганы для японского текста.
  3. Пользователь может запросить показ похожих карточек для контекста.
  4. Пользователь думает над ответом.
  5. Пользователь запрашивает показ ответа.
  6. Система отображает ответ, примеры использования и фуригану (если применимо).
- **Постусловия**: Пользователь переходит к оценке ответа.

#### Use Case 8: Оценка ответа на карточку

- **Актер**: Пользователь.
- **Предусловия**: Пользователь просмотрел карточку и увидел ответ.
- **Основной поток**:
  1. Система предлагает варианты оценки ("легко", "хорошо", "трудно", "забыл").
  2. Пользователь выбирает оценку.
  3. Система сохраняет выбор и рассчитывает следующее повторение.
- **Альтернативные потоки**: Если оценка не выбрана, система напоминает и ждет.
- **Постусловия**: Оценка зафиксирована, готовится следующая карточка.

#### Use Case 9: Начало сессии изучения

- **Актер**: Пользователь.
- **Предусловия**: Пользователь авторизован, есть карточки в системе.
- **Основной поток**:
  1. Пользователь запрашивает начало сессии изучения.
  2. Система находит все карточки, готовые к повторению (next_review_date <= текущее время).
  3. Система разделяет карточки на старые (с историей повторений) и новые.
  4. Система сортирует старые карточки по дате следующего повторения (самые просроченные первыми).
  5. Система сортирует новые карточки по количеству повторений и дате создания.
  6. Система ограничивает количество новых карточек согласно лимиту пользователя (если не указан флаг принудительного показа всех).
  7. Система объединяет списки и перемешивает их.
  8. Для каждой карточки система определяет, нужно ли ее перевернуть (для известных карточек вероятность переворота 65%).
  9. Для каждой карточки система находит похожие карточки через embedding similarity.
  10. Система возвращает список карточек для изучения.
- **Альтернативные потоки**: Если нет карточек, готовых к повторению, система возвращает пустой список.
- **Постусловия**: Пользователь получает список карточек для изучения.

#### Use Case 10: Автоматическое планирование повторений

- **Актер**: Пользователь.
- **Предусловия**: Пользователь оценил карточку (Use Case 8).
- **Основной поток**:
  1. Система получает оценку карточки и предыдущее состояние памяти.
  2. Система рассчитывает интервал повторения и новое состояние памяти через SRS Service (FSRS).
  3. Система создает Review с оценкой и интервалом.
  4. Система обновляет карточку: добавляет Review, устанавливает next_review_date и memory_state (stability и difficulty).
  5. Система сохраняет изменения.
- **Альтернативные потоки**: Если расчет SRS не удался, система возвращает ошибку.
- **Постусловия**: Карточка запланирована на следующее повторение, состояние памяти обновлено.

#### Use Case 11: Завершение урока

- **Актер**: Пользователь.
- **Предусловия**: Пользователь завершил сессию изучения.
- **Основной поток**:
  1. Пользователь завершает урок.
  2. Система рассчитывает статистику урока: среднюю стабильность, среднюю сложность, общее количество слов, количество известных слов, количество новых слов.
  3. Система сохраняет запись в историю уроков.
- **Постусловия**: Статистика урока сохранена, пользователь может просмотреть историю.

### FR3: Управление профилем и настройками

#### Use Case 12: Просмотр информации о пользователе

- **Актер**: Пользователь.
- **Предусловия**: Пользователь авторизован.
- **Основной поток**:
  1. Пользователь запрашивает информацию о себе.
  2. Система отображает имя пользователя, родной язык, уровень японского, лимит новых карточек.
  3. Система отображает статистику: общее количество карточек, количество известных карточек, количество новых карточек.
  4. Система отображает график истории уроков с динамикой стабильности и сложности.
- **Постусловия**: Пользователь видит свою статистику и прогресс.

## Доменная модель

Модель построена по принципам DDD. Агрегатный корень — User. Все операции обеспечивают согласованность.

### Сущности

1. **User (Агрегатный корень, Entity)**  
   Владелец карточек и процессов обучения. Хранит коллекцию карточек, настройки пользователя (родной язык, уровень японского, лимит новых карточек в день) и историю уроков. Отвечает за создание, редактирование и удаление карточек, а также за формирование сессий изучения. При создании карточек проверяет дубликаты через сравнение embeddings (cosine similarity). При формировании сессии изучения разделяет карточки на старые и новые, сортирует их и ограничивает количество новых карточек. Может находить похожие карточки для любой карточки через embedding similarity.

2. **Card (Дочерняя сущность, Entity)**  
   Флеш-карточка с японским словом (вопрос) и переводом (ответ). Хранит историю повторений (reviews), дату следующего повторения, состояние памяти для алгоритма FSRS (стабильность и сложность), а также примеры использования слова. Вопрос содержит embedding для поиска похожих карточек. Карточка может быть новой (еще не была успешно повторена), известной (была оценена как "легко" хотя бы раз) или готовой к повторению (дата следующего повторения наступила).

3. **Review (Дочерняя сущность, Entity)**  
   Запись оценки карточки. Содержит оценку пользователя (Easy, Good, Hard, Again), время оценки и интервал до следующего повторения, рассчитанный алгоритмом FSRS.

4. **StudySessionItem**  
   Элемент сессии изучения. Представляет карточку в контексте текущей сессии. Может быть перевернут (shuffled), содержать фуригану для японского текста, список похожих карточек и примеры использования. Используется для отображения карточки пользователю во время изучения.

### Value Objects (Неизменяемые объекты)

- **Question**: Текст вопроса (японское слово) и его векторное embedding для поиска похожих карточек. Текст не может быть пустым после обрезки пробелов.

- **Answer**: Текст ответа (перевод). Текст не может быть пустым после обрезки пробелов.

- **ExamplePhrase**: Пример использования слова. Содержит предложение на японском языке и его перевод на родной язык пользователя.

- **Rating**: Оценка карточки пользователем. Варианты: Easy (легко), Good (хорошо), Hard (трудно), Again (забыл).

- **Stability**: Стабильность карточки в алгоритме FSRS. Значение не может быть отрицательным. Показывает, насколько прочно запомнена карточка.

- **Difficulty**: Сложность карточки в алгоритме FSRS. Значение не может быть отрицательным. Показывает, насколько сложна карточка для запоминания.

- **MemoryState**: Состояние памяти для алгоритма FSRS. Содержит стабильность и сложность карточки. Используется для расчета следующего интервала повторения.

- **JapaneseLevel**: Уровень японского языка пользователя. Варианты: N5 (начальный), N4, N3, N2, N1 (продвинутый).

- **NativeLanguage**: Родной язык пользователя. Варианты: English, Russian. Используется для генерации переводов и примеров.

- **LessonHistoryItem**: Запись в истории уроков. Содержит время урока, среднюю стабильность и сложность всех карточек, общее количество слов, количество известных слов и количество новых слов на момент урока.

## Обработка ошибок

Система использует единый тип ошибок `JeersError` для всех слоев приложения. Это обеспечивает согласованную обработку ошибок и упрощает их передачу между слоями.

### Типы ошибок

1. **UserNotFound**  
   Пользователь с указанным идентификатором не найден. Возникает при попытке выполнить операцию с несуществующим пользователем.

2. **UserNotFoundByUsername**  
   Пользователь с указанным именем не найден. Возникает при поиске пользователя по имени.

3. **CardNotFound**  
   Карточка с указанным идентификатором не найдена. Возникает при попытке выполнить операцию с несуществующей карточкой (редактирование, удаление, оценка, планирование повторения).

4. **DuplicateCard**  
   Карточка с похожим вопросом уже существует. Возникает при создании новой карточки или редактировании существующей, если embedding вопроса слишком похож на embedding другой карточки (cosine similarity >= 0.9999). При редактировании текущая карточка исключается из проверки.

5. **InvalidQuestion**  
   Некорректный вопрос. Возникает при создании или редактировании карточки, если текст вопроса пустой (после trim).

6. **InvalidAnswer**  
   Некорректный ответ. Возникает при создании или редактировании карточки, если текст ответа пустой (после trim).

7. **InvalidStability**  
   Некорректное значение стабильности. Возникает при попытке установить отрицательное значение стабильности.

8. **InvalidDifficulty**  
   Некорректное значение сложности. Возникает при попытке установить отрицательное значение сложности в состоянии памяти.

9. **InvalidMemoryState**  
   Некорректное состояние памяти. Возникает при создании или преобразовании состояния памяти с невалидными параметрами.

10. **SrsCalculationFailed**  
    Ошибка расчета алгоритма интервального повторения (FSRS). Возникает при сбое в работе библиотеки fsrs-rs (инициализация, расчет следующего состояния, преобразование данных).

11. **RepositoryError**  
    Ошибка работы с хранилищем данных. Возникает при операциях с базой данных (поиск, сохранение, удаление).

12. **EmbeddingError**  
    Ошибка генерации embedding. Возникает при сбое в работе сервиса генерации embeddings.

13. **LlmError**  
    Ошибка работы с LLM. Возникает при сбое в генерации переводов или примеров использования через LLM.

14. **SettingsError**  
    Ошибка настроек приложения. Возникает при проблемах с конфигурацией или инициализацией компонентов.

15. **FuriganaError**  
    Ошибка генерации фуриганы. Возникает при сбое в работе сервиса генерации фуриганы.

## Компоненты системы

Архитектура основана на Clean Architecture с тремя слоями. Интеграция с FSRS (Rust, fsrs crate версии 5.2) для расчета интервалов повторения, SurrealDB (Rust SDK версии 2.3, локальное хранилище на RocksDB) для хранения данных, и различными LLM сервисами (OpenAI, Gemini, локальные модели через Candle) для генерации переводов и примеров. Система использует векторные embeddings для поиска похожих карточек и сервис фуриганы для отображения чтения японских слов.

[Диаграмма C4](./arch.c4)
